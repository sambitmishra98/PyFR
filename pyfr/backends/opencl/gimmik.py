from gimmik import OpenCLMatMul
import numpy as np

from pyfr.backends.base import NotSuitableError
from pyfr.backends.opencl.provider import OpenCLKernel, OpenCLKernelProvider

from pyfr.util import digest 


class OpenCLGiMMiKKernels(OpenCLKernelProvider):
    def __init__(self, backend):
        super().__init__(backend)
        self.cfg = backend.cfg

        # Maximum number of non-zeros
        self.max_nnz = backend.cfg.getint('backend-opencl', 'gimmik-max-nnz',
                                          2048)

        # Maximum number of kernels to consider
        self.nkerns = backend.cfg.getint('backend-opencl', 'gimmik-nkerns', 8)

        # Number of benchmarking runs
        self.nbench = backend.cfg.getint('backend-opencl', 'gimmik-nbench', 5)

        # Kernel cache
        self._mul_kerns = {}

    def mul(self, a, b, out, alpha=1.0, beta=0.0):

        # Matrix a has one tag starting with M. Get that tag.
        matrix_tag = next(tag for tag in a.tags if tag.startswith('M'))

        # Modify a few of them 
        if matrix_tag == 'M1 - M3*M2':
            matrix_tag = 'M132'
        elif matrix_tag == 'M4 - M6*M0':
            matrix_tag = 'M460'
            
        kerns = self.cfg.getliteral('backend-opencl', f'gimmik-kerns-{matrix_tag}', [-1])
        # kerns is supposed to be a list of integers, with each entry between 0 to 9
        # If given input 123, it will be converted to [1, 2, 3]
        # If input is -1, then it will be converted to [-1]

#        if kerns == -1:
#            kerns = [-1,]
#        else:
#            kerns = [0,] + [int(k) for k in kerns]
#
        # Ensure the matrices are compatible
        if a.nrow != out.nrow or a.ncol != b.nrow or b.ncol != out.ncol:
            raise ValueError('Incompatible matrices for out = a*b')

        # Check that A is constant
        if 'const' not in a.tags:
            raise NotSuitableError('GiMMiK requires a constant a matrix')

        # Fetch the matrix
        arr = a.get()

        # Check that A is reasonably sparse
        if np.count_nonzero(arr) > self.max_nnz:
            raise NotSuitableError('Matrix too dense for GiMMiK')

        # Dimensions
        ldb, ldc = b.leaddim, out.leaddim

        # Alignment
        if 'align' in b.tags and 'align' in out.tags:
            aligne = self.backend.alignb // b.itemsize
        else:
            aligne = None

        # Cache key
        ckey = (a.mid, alpha, beta, aligne, ldb, ldc)

        # Check the kernel cache
        try:
            kern, gs, ls, dt = self._mul_kerns[ckey]

            # Clone the kernel so it gets its own set of arguments
            kern = kern.clone()
        except KeyError:
            kname = f'gimmik_mm_{arr.shape[0]}x{arr.shape[1]}'
            local_mem_size = self.backend.cl.dev.local_mem_size
            best_kern = None
            chosen_kern = None
            sdata = None

            # Save a copy of the contents of the output matrix
            out_np = getattr(out, 'parent', out).get()

            mm = OpenCLMatMul(alpha*arr, beta=beta, aligne=aligne, n=b.ncol,
                              ldb=ldb, ldc=ldc)
            kgen = mm.kernels(a.dtype, kname=kname,
                              local_mem_size=local_mem_size)

            # Benchmark the sequence of kernels generated by GiMMiK
            try:
                for i in range(self.nkerns):
                    src, meta = kgen.send(sdata)

                    gs, ls = meta['global_work_size'], meta['local_work_size']
                    kern = self._build_kernel(kname, src, 'PP')

                    # Set the parameters
                    kern.set_dims(gs, ls)
                    kern.set_args(b, out)

                    # Obtain the runtime
                    dt = self._benchmark(
                        lambda queue: kern.exec_async(queue, ret_evt=True),
                        nbench=self.nbench
                    )

                    self.backend.bench_kern |= {
                                f'{kname}_a-tags': matrix_tag,
                                f'{kname}_a-rows': a.nrow, 
                                f'{kname}_a-cols': a.ncol,
                                f'{kname}_b-cols': b.ncol,
                                f'{kname}_nnz': np.count_nonzero(arr),
                                f'test-{i}_{kname}_gs-grid': gs, 
                                f'test-{i}_{kname}_ls-block-tgrp': ls,
                                f'test-{i}_{kname}_Runtime': dt
                                }

                    if best_kern is None or dt < best_kern[-1]:
                        if i in kerns:
                            self.backend.bench_kern |= {f'best-{kname}': i}
                            best_kern = kern, gs, ls, dt
                        else:
                            print(f'Skipping {kname} {self.backend.bench_kern[f"{kname}_a-tags"]} {i}')

#                        if i in kerns:
#                            self.backend.bench_kern |= {f'chosen-{kname}': i}                            
#                            chosen_kern = kern, gs, ls, dt
#
                    sdata = {'runtime': dt}
            except StopIteration:
                pass

            # Restore the output matrix
            getattr(out, 'parent', out).set(out_np)

            # Update the cache
            self._mul_kerns[ckey] = kern, gs, ls, dt = best_kern

        # Set the parameters
        kern.set_dims(gs, ls)
        kern.set_args(b, out)

        class MulKernel(OpenCLKernel):
            def run(self, queue, wait_for=None, ret_evt=False):
                return kern.exec_async(queue, wait_for, ret_evt)

        return MulKernel(mats=[b, out], dt=dt)
